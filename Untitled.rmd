---
title: "R Notebook"
output: html_notebook
---

```{r}
# install.packages("arules")
# install.packages("arrow")

library(tidyverse)
library(lubridate)
library(arules)
library(arrow)
```


```{r}
retail <- read.csv("data/online_retail_II.csv")
head(retail)
```

```{r}
summary(retail)
```

```{r}
# convert Invoice to date
retail <- retail %>%
  mutate(InvoiceDate = parse_date_time(InvoiceDate, orders = c("ymd HMS")))

# making sure Invoice and StockCode are char
retail <- retail %>%
  mutate(
    Invoice = as.character(Invoice),
    StockCode = as.character(StockCode)
  )

# sort chronologically
retail <- retail %>%
  arrange(InvoiceDate)
```

```{r}
retail %>%
  filter(str_starts(Invoice, "C")) %>%
  head()

# every invoice starting with "C" already has negative values
tab <- retail %>%
  mutate(is_c = str_starts(Invoice, "C"),
         qty_neg = Quantity < 0) %>%
  count(is_c, qty_neg)

tab

# keep only sales (no returns)
sum(str_starts(retail$Invoice, "C"))

retail <- retail %>%
  filter(!str_starts(Invoice, "C"), Quantity > 0, Price > 0)
```

```{r}
sort(unique(retail$Country))

# filter for 'United Kingdom' transactions only
retail <- retail %>% filter(Country == "United Kingdom")
```

```{r}
# compute Total
retail <- retail %>%
  mutate(Total = Quantity * Price)
```

```{r}
nums <- retail %>% select(Quantity, Price, Total)
bad <- which(
  rowSums(is.na(nums)) > 0 |
  rowSums(nums == 0, na.rm = TRUE) > 0 |
  rowSums(nums < 0,  na.rm = TRUE) > 0
)
bad
```
```{r}
head(retail)
```

```{r}
# build baskets - one of each item per invoice
basket_df <- retail %>%
  filter(!is.na(StockCode)) %>%
  distinct(Invoice, StockCode)

baskets <- split(basket_df$StockCode, basket_df$Invoice)
tx <- as(baskets, "transactions")              # sparse basket matrix

# --- Apriori with your thresholds ---
rules <- apriori(
  tx,
  parameter = list(supp = 0.002, conf = 0.4, minlen = 2, target = "rules")
)

# keep lift >= 1.2
rules <- subset(rules, quality(rules)$lift >= 1.2)

# --- export only requested columns ---
out <- tibble(
  antecedent = labels(lhs(rules)),
  consequent = labels(rhs(rules)),
  support    = quality(rules)$support,
  confidence = quality(rules)$confidence,
  lift       = quality(rules)$lift
)

arrow::write_parquet(out, "rules.parquet")

# (optional) peek at top rules by lift
out %>% arrange(desc(lift)) %>% head(10)
```
```{r}
pairs <- eclat(tx, parameter = list(supp = 0.002, minlen = 2, maxlen = 2))
inspect(head(sort(pairs, by = "support"), 10))
```

```{r}
# 1) One best description per StockCode -> named vector
map_desc <- retail %>%
  filter(!is.na(StockCode), !is.na(Description)) %>%
  count(StockCode, Description, sort = TRUE) %>%
  group_by(StockCode) %>% slice_max(n, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  { setNames(.$Description, .$StockCode) }

# 2) Build unique, human-readable item labels: "CODE | Description"
basket_df <- retail %>%
  filter(!is.na(StockCode)) %>%
  mutate(desc = map_desc[StockCode],
         item = if_else(is.na(desc), StockCode, paste0(StockCode, " | ", desc))) %>%
  distinct(Invoice, item)

# 3) Baskets -> transactions
baskets <- split(basket_df$item, basket_df$Invoice)
tx <- as(baskets, "transactions")

# 4) Frequent pairs (undirected “bought-together”)
pairs <- eclat(tx, parameter = list(supp = 0.002, minlen = 2, maxlen = 2))

# 5) See the top 10 pairs (now with names)
inspect(head(sort(pairs, by = "support"), 10))


```

